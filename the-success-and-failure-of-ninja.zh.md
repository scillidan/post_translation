# [Ninja的成功与失败](https://neugierig.org/software/blog/2020/05/ninja.html)

大约九年前，我发布了Ninja，一种大致可比作Make的构建系统。当时[我有些尴尬地分享我的副项目](https://neugierig.org/software/chromium/notes/2011/02/ninja.html)，但从那时起，它已经变得非常受欢迎。

如今，我无法再一口气列出所有用户，但一些使用Ninja的“大”项目包括：

- Chrome，最终移除了所有非Ninja构建；
- Android，它在一些我从未完全理解的大型系统组件中使用它；
- 所有[Meson](https://mesonbuild.com/)项目，似乎越来越多地成为自由软件世界中使用的构建系统；
- 许多其他与CMake一起使用Ninja的项目（以一个随机的例子来说，[Swift编程语言的构建说明](https://github.com/apple/swift#system-requirements)告诉你要安装Ninja）。

Ninja无疑是我最成功的开源项目，这要看你如何量化成功。（其他我的项目如Chrome有更多用户，但我只对Chrome的部分负责；虽然Ninja也得到了合作者的重要贡献，但它更像是“我的”项目。）我在2011年发布了Ninja，在2014年将Ninja项目的所有权转让出去，此后又交给了第三位维护者，现在我的部分故事几乎结束，所以我想在这里反思一下我所学到的。

如果要用一句话总结我所学到的，便是：我们谈论编程时，通常觉得它与写代码有关，但代码的实际重要性远不及架构，而架构的实际重要性又远不及社会问题。

也就是说，作为程序员，我们喜欢把问题当作主要技术问题来讨论——“我该如何优化这个循环，以从这个服务中挤出更多的QPS？”——但在我的经验中，技术几乎总是次于更大局面的因素。我后来也看到许多人用不同的说法描述了从“初级”到“高级”工程师的旅程，这种描述与我的职业生涯非常吻合，因此我希望在这次回顾中对这一点有所阐释。

## 技术

让我们先处理一些技术细节。

Ninja的具体功能相当简单；根据要求的描述，我希望一个合格的本科生，可能在系统课程上，能够在没有太多帮助的情况下写出一个基本版本。总结一下，用户给Ninja一个`ninja.build`文件（省略一些细节），它包含了你希望Ninja运行的所有命令，以及每个命令消耗和产生的文件。Ninja加载这个文件，检查各种文件的修改时间，并并行执行需要的命令，以使所有内容保持最新。与Make类似（它基本上做相同的事情），Ninja在其输入构建语言中提供了更少的功能，主要结构围绕着使其具有的少数功能尽可能快速。

Ninja所做的几件事情是：（1）解析和解释构建文件；（2）检查输入文件的修改时间；（3）执行需要的命令。其目标是在大型项目（>10万输入文件）上尽快达到第3步，而完成这些则是通过一系列小而精细的优化。例如，Ninja仔细地将每个输入文件路径映射到一个独特的内存对象，并利用指针比较这些对象来测试路径的相等性（有效地实现了字符串的归一化）。我为《开源软件的性能》一书写了一章关于Ninja的内容，讲述了使其快速的一些底层技术细节，你[可以在线阅读](https://www.aosabook.org/en/posa/ninja.html)。

多年来，很多人对Ninja进行了重写。这是一个小项目，因此尝试在你喜欢的语言中实现它很有趣。例如，[llbuild](https://github.com/apple/swift-llbuild)和[Shake](https://shakebuild.com/)都支持Ninja文件作为输入，而[Samurai](https://github.com/michaelforney/samurai)几乎是逐文件重新实现（代码更少，但功能更少且没有测试！）。至我所知，没有人能制作出更快的实现。

## 一些架构注意事项

Ninja的一些部分经过斗争最终变得显而易见。我认为这符合数学的许多特性，一旦你将想法提炼到本质，它们似乎是显而易见的。其力量来自于以正确的方式思考问题。我在Ninja的设计过程中大多是碰撞前行，但在我走出它的另一端时，我意识到自己意外地打到了设计空间中的一些好点。以下是一些例子。

**图形表示**。Make对构建规则生成多个文件的情况处理不佳。我不知道Make如何在内部结构化，但我猜它是以文件之间的图来表示构建结构的，因为输入语法看起来就是这样，而且这种结构会产生该行为。Ninja则使用文件和命令之间的二分图，其中文件节点是指向命令节点的边，而命令节点又向外指向文件。这种表示更好地捕捉了构建的结构：如果任何输入发生变化，命令就会过期，而它在运行时会更新所有输出。（一个图形不变性是，给定的文件至多只能有一个输入边。）此外，注意命令行本身也可以被视为命令节点的一个输入，即如果命令行标志发生变化，命令过期（因此它的输出也过期）。

**依赖关系日志**。为了正确获取C头文件的依赖关系，你需要消耗由C编译器生成的附加依赖数据。更多内容可以参考[这本章节](https://www.aosabook.org/en/posa/ninja.html)。我记得曾为是否引入数据库而苦恼，以及如何将其与我对简单性的期望调和，直到我最终想出了一个[表示格式](https://github.com/ninja-build/ninja/blob/master/src/deps_log.h#L29)，结果非常紧凑。（不幸的是，这在某些重要方面仍然是错误的，但算了。）

**端到端/崩溃优先**。Ninja不是一个持久的守护进程，而是在每次执行时从头开始完成所有工作。这是故意的，是[端到端原则](https://en.wikipedia.org/wiki/End-to-end_principle)和[崩溃优先软件](https://en.wikipedia.org/wiki/Crash-only_software)的混合，也就是说：考虑到有时需要从头运行Ninja，如果你能让它快，那么就不需要构建第二个“在线”代码路径。能够保持驻存内存的项目最终往往会让他们的启动性能逐渐下降。

**文件状态**。程序员有时期望构建工具驻存在内存，是因为他们希望能够缓存磁盘上文件的状态。但实际上，内核已经在内存中缓存了这些信息，而在用户级缓存一次并不会为你节省太多；从Linux获取文件状态的速度极快。Ninja甚至只用一个线程来完成这项工作。在十年前一个“快速”的机器上，你可以[在10毫秒内统计30k个文件](https://github.com/ninja-build/ninja/wiki/Timing-Numbers)。（一个编程笑话：一半的性能问题是通过引入缓存来解决的；另一半则是通过删除一个来解决的。）

**数量级**。一个经验法则是，你可以通过优化将规模提高两倍，但要提高十倍则需要重新架构。Ninja是在Chrome的构建上设计的，当时大约有3万构建步骤。这些天，它被用于更小的设置，在这些情况下可能并不需要（见下文关于速度的讨论），以及在更大的设置中，如Android构建，在那里它在扩展性上遇到了瓶颈，并可能需要另一种方法。

**未充分说明和过分说明**。Ninja并行执行命令，因此要求用户提供足够的信息以确保正确性。但在另一个极端上，它也并不强制要求它具备构建的完整图景。你可以在[这个特定的bug讨论的](https://github.com/ninja-build/ninja/issues/1303)中看到这一动态（搜索“evmar”以查看我的评论）。通常，你必须在正确性与便利性或性能之间进行妥协，并且在选择这个连续体上的某个点时应有所考量。我发现一些程序员在考虑这一动态时不够灵活，似乎很明显其中一个关注点主导，但在我的经验中，相互影响相当微妙；例如，一个在正确性与便利性之间进行权衡的工具可能整体上会产生一个比一个更正确但不那么方便的替代工具更正确的生态系统，前提是程序员最终避开了后者。（这可能是[Haskell不够成功的原因之一](https://neugierig.org/software/blog/2011/10/why-not-haskell.html)。现在我在编程语言方面工作，我看到这一动态时常发生。）

最终，最大的架构见解是：

## "汇编器"隐喻

当人们思考构建系统时，他们会想到各种各样的功能，广泛得以至于构建系统有时甚至无法与不同工具之间进行比较。针对这些工具的市场营销文本通常讨论输入语法的用户友好性。

Ninja的见解（事后发现）是，无论这些工具具有多高层的功能，最终都必须构建某种类型的_动作图_：它们打算保持最新的文件和要执行的命令。Ninja只实现了那个动作图，并让用户选择另一个“生成器”程序在上面。

我最初发明这个两个程序的分离恰好是因为它刚好适合我当时正在工作的项目（Chrome），但我后来意识到这是Ninja的主要贡献。

一方面，它让我能够让Ninja变得简单而快速，因为任何耗时的工作（例如“全局搜索\*.c”）都被迫放到生成器中。与其他在一次处理过程中完成所有工作的构建系统相比，Ninja的设计有效地迫使你在计算出动作图后，将其“快照”到磁盘。另一种看待这个问题的方法是，它有效地将动作图在构建之间进行缓存。

另一方面，这也意味着Ninja可以以非常灵活的方式使用，因为生成器可以与用户的需求一样高层（“测试是通过对整个源树查找名字中带有'test'的文件而找到的”）。重要的是，它迫使使用Ninja的开发者决定他们愿意支付什么。如果他们的生成器程序想要在磁盘上广泛查找文件，它是完全可以的，但那时他们会更清楚地意识到他们的构建为何会缓慢。

（我应该在这里指出，生成器与生成的动作图之间的干净分离并不像我描述的那样简单。Ninja最终有很多琐碎的细节，这些细节都在争论哪一层工作属于哪一层，但很难把学到的教训写出来。）

这一设计方面的讽刺是，没有什么可以阻止其他人这样做。Xcode或Visual Studio的构建系统（例如）同样可以这样做：在前面做大量工作，然后快照结果以快速重新执行。我认为如此之少成功的原因是，因为混合层的诱惑太大。

Ninja最接近的相对是Make，它试图涵盖所有面向程序员的功能（通过全局查找、变量扩展、子串、函数等），最终导致一种编程语言过于弱小，无法表达所有所需的功能（见autotools），但仍然足够强大，允许人们编写慢速的Makefile。这在某种程度上是[Greenspun的第十条法则](https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule)，我强烈尝试避免在Ninja中出现。

## 默认主导

默认情况下，Ninja并行执行所需命令。Make也可以做到这一点；Ninja借用了相同的标志名称来实现这一能力（`-j`），只是使用了不同的默认值。然而，由于Make默认按顺序运行命令，因此相对容易编写一个不充分说明依赖关系的Makefile，从而使其以并行方式执行是不安全的。实际上，甚至还有某个商业供应商提供某种“Makefile加速器”工具，帮助人们发现和修复不充分说明的依赖关系。

相比之下，由于Ninja总是并行执行命令（即使在单核系统上），它最终更早地揭示了这种错误。这意味着使用Ninja构建的程序通常在并行构建时是安全的。（Ninja没有复杂的系统来检测你何时犯了错误，它只是在更多情况下导致错误的构建。）相比之下，用户通常会忘记或不了解Make使其也能并行运行的标志。为此感到尴尬，因为这只是一个标志，但仅因其默认值，Ninja在使用不小心的用户中最终也将“比Make快两倍”或更多。这一教训是，如果你的用户并没有真正看到世界上的所有优化，那些优化将毫无意义。

## 速度

在这篇文章中，我几次谈到了性能，重要的是要注意，在构建系统中有很多种不同的性能指标。例如，有人可能关心“从头开始构建要花多长时间？”Ninja专注于大代码库的编辑-编译周期的_增量_构建，也就是说，你已经执行了一个构建，编辑了一次文件，然后运行下一个构建。

在我编写Ninja时，我记得blaze（也称为[bazel](https://bazel.build/)）非常快，但自从我最后一次使用它已经过了很多年。由于这种记忆，我不断尝试使Ninja更快，以试图赶上我对blaze的记忆。具有讽刺意味的是，blaze在我所关心的速度指标上并不特别快；由于blaze是一个Java程序，即使让blaze输出其“帮助”信息也是相当慢的。

我执着于增量构建，这也许显得有些傻，但我坚信迭代时间对程序员的满意度影响巨大，而Ninja正是在编辑-编译循环中使用的，1秒与4秒的区别至关重要。我个人认为我比普通程序员更敏感于延迟，但我相信程序员会“感受到”延迟，即便他们没有注意到，这会影响他们的情绪。（谷歌最近在这个领域做了一些研究，confirm了我的信念，希望他们会公开发布！）

很难向用户传达“快”的多种可能含义。Ninja手册试图警告人们不要在小程序上使用它。实际上在引言后的[第二段](https://ninja-build.org/manual.html#_using_ninja_for_your_project)中就写道：“如果你的项目很小，Ninja的速度影响可能不明显”，并建议使用其他构建系统。不幸的是，“快”是有市场的，Ninja列表上经常有用户试图在他们的小型应用上使用它，并因为缺乏特性而感到沮丧。

虽然Ninja专注于增量重构的性能，但一些用户报告称Ninja也提高了他们的端到端构建性能。这是意外的，但原因在于Ninja（再次由于几乎不做任何事情）在进行这些构建时消耗了非常少的CPU，而可比程序在运行时不知为何消耗更多的CPU，这也把CPU从基础构建中抽离了。

在我的文章[“对于一个浏览器来说，快速意味着什么”](https://neugierig.org/software/chromium/notes/2010/05/fast.html)中，我探讨了速度有多少方面，最终重要的是用户的_速度感知_。Ninja在输出上非常简洁：对于大多数成功构建，它只打印一行。相比之下，其他构建系统往往打印大量（通常是多余的彩色）输出以及构建进行的各个阶段的时间数字，这使得它们感觉沉重。Ninja由于说得少，使得它的存在感似乎更低。

## CMake

我最初构建Ninja是为了与Chrome的奇特构建系统配合使用，并就此停止了。某位名叫彼得·科林博恩的陌生人发现了Ninja，并进行了将其与更流行的CMake构建系统连接的工作。Ninja的设计与CMake非常契合，但总是需要解决许多细节，彼得在这方面做了大部分的工作，最初是希望能通过Ninja处理LLVM。这不仅是CMake的问题，还需要在Ninja中构建新的语义。如果在现实世界中有人对Ninja的成功负责，那就是彼得。

CMake的作者们最终接管了这一整合，而我为自己未能更好地支持他们感到愧疚；他们对我非常友好和耐心，但我从未真正有时间回答他们的请求或关切。布拉德，如果你读到这篇文章，我非常抱歉！到今天为止，我实际上从未使用过CMake，我从来没有时间去担心这个问题。

## Windows

由于Ninja的动力项目是Chrome，而Chrome也支持Windows，因此我们使其在Windows上运行。（Ninja的这一部分主要是由[一位贡献者](http://h4ck3r.net/)编写的。）

在技术层面上，支持Windows大致上都是个麻烦。Linux代码在出现不适用的地方时，需要有无趣的抽象或重大重新设计。就前者而言，生成进程并捕获它们的输出在两个平台之间是非常不同的，但主要在于你需要学习一个完全不同的API。就后者而言，Ninja的设计以你可以快速获取内核缓存文件的最后修改时间的特性为中心，而[这一点在Windows上并不成立](https://github.com/ninja-build/ninja/wiki/Timing-Numbers)。

但是Windows在开发人员中依然是一个巨大的平台，而这些开发人员对于工具的需求非常迫切。潜在的动态是，当有人制造出一个很棒的Linux工具时，冲动是分享它，但当他们为Windows这样做时，冲动却变成了出售它，因此相应地，也就没有那么多工具可以在Windows上自由使用。

我惊讶于早期的Ninja用户中有多少是Windows用户，但回想起来这有点显而易见：即便只有1%在Windows的开发者关心Ninja，但Windows的用户人数如此之多，他们最终会出现。（在Linux的Chrome早期，我们经常这样讨论：即便我们让~所有桌面Linux用户使用Chrome，总体人类数量对Windows用户的增加也不过是5%的样子。你可以不同意这个数字的具体值，但希望你能明白我的意思。）

## 相关工作

我提到过自己是在Ninja的设计中经历过曲折。我很后悔没有在构建之前花更多时间进行研究，但我起初打算将整个项目只当作一次周末的演示黑客，而非认真对待。（相关地，请原谅我这个尴尬的名字。）自那以后，我开始意识到在构建事物时了解设计空间的重要性。我现在发现程序员讨论相关工作是多么罕见，这让我感到非常沮丧。

我上面使用的术语（“动作图”）不是我当时在Ninja中想到的，而是取自谷歌的构建系统（“blaze”/“bazel”）。在bazel中，他们明确谈到有一个目标的图（更高层的用户概念，如“库”和“二进制”）以及这如何生成[动作图（命令）](https://docs.bazel.build/versions/master/bazel-overview.html#how-does-bazel-work)。

我在上面提到了一些命令行文本可以被视为“输入”，就像文件一样。这是增量计算的更广泛概念的一个特定实例，这不仅涵盖构建系统，也涵盖UI中的增量性。我的朋友[Rado](https://twitter.com/radokirov)在这一领域的研究中一直在阅读过去一年的研究，并正在撰写一系列尝试总结这一领域的博客文章；请留意。Jane Street的博客也有关于总结这一领域的一些工作[在这里](https://blog.janestreet.com/introducing-incremental/)；正如你所看到的，甚至还与我们最近在UI构建方面的复兴（如React）有所关联。

一篇精彩的论文[“构建系统à la Carte”](https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems-final.pdf)在构建系统的背景下讨论了增量计算。我希望这篇论文能在我撰写Ninja之前就能存在。

## 开源

最后，我想谈谈作为一个开源维护者的体验。如你可能在其他地方读到的那样，这并不是特别好玩。（[这场演讲“This talk "The Hard Parts of Open Source"](https://www.youtube.com/watch?v=o_4EX4dPppA)值得你花时间去看。）

当我试图总结自己对整个项目的总体感觉时，它是偶尔的自豪，与我看到有人在proggit或HN上说一些好话时的自豪感，以及一种更大范围的失望感。

我做了一个我认为很酷的东西，并将它奉献出来，而我所获得的回报是在友好的人们温和请求我的东西的同时，更多的是愤怒的用户对我提要求，几乎没有人说声谢谢。人们一再威胁要分叉这个项目，因为我不同意他们的要求，却从未考虑过我在设计空间中可能拥有更多的上下文。

另一种悲伤的来源是那些友好和聪明的人，他们提出看似合理的贡献，却与我的设计目标冲突，我希望通过详细解释为什么拒绝他们来回报他们的努力，而这样做本身就是一种消耗。

我通过自由软件入门编程，我编写代码希望回馈给那些给予我那么多的人。（如果你正在阅读这篇文章，我敢打赌你正受益于我一项或多项的自由软件贡献。）但如今我看到自由软件并不真的代表在平等之间分享；人们反而认为自己是消费者，把作者视为可以去向经理投诉的对象。

换个说法，如今我只是试图 impress 或追随我钦佩的约十位黑客，比如apenwarr、agl、bradfitz或graydon，尽管偶尔碰到某个人，并让我的软件名声在先确实很酷，但我认为许多“成功”其实只是一个负担。我认为我可以在更小的成功中学到一样多的东西。

## 最后致谢

我在这篇文章中提到了几位人士，但我还想特别感谢尼科·韦伯，不仅因为他是一个谨慎的合作者，还因为他多年来担任了Ninja的维护者；也谢谢扬·尼克拉斯·哈斯，他在尼科之后接手了这个角色，虽然我根本不认识他，但他似乎做得很好。最后，感谢众多[为Ninja贡献的作者](https://github.com/ninja-build/ninja/graphs/contributors)。

[GPT-4o mini]
