# [Linux启动过程：从电源按钮到内核](https://www.0xkato.xyz/linux-boot/)

## 第一部分 — 从电源按钮到内核的第一口气

你按下电源按钮。一秒钟后，一大堆文本滚动过去，或者一个logo渐渐显现，最终Linux出现在屏幕上。在此之间发生的事情并不是魔法，而是微小程序与CPU之间的精密握手。本部分描述这一握手，直到Linux内核内部的第一行C代码运行。

### 第一条指令

当电源稳定后，CPU重置到一个小型、老式的叫做“实模式”的模式。实模式可以追溯到最初的8086芯片。规则是故意简单。内存地址由CPU保存在特定快速存储（称为寄存器）的两个值构成。你将段和偏移量组合如下：

`physical_address = (segment << 4) + offset`

如果你看到像`0xFFFFFFF0`这样的数字，那是十六进制数。十六进制是以16为基数的。我们在前面加上`0x`以明确表示。`0x10`在日常数数中是16。`0x100000`是1兆字节。十六进制与硬件存储比特的方式相一致，因此你在低级代码中经常看到它。

在重置后，CPU跳转到一个称为重置向量的特殊地址`0xFFFFFFF0`。将它想象成一个永久的书签，标记“从这里开始”。在该地址几乎没有空间，因此制造商在这里放置了一个短跳转，控制权转交给你主板上的固件。

**小解释：寄存器** 寄存器是CPU内部的一个微小槽位。它保存当前CPU正在使用的数字。像CS和IP这样的名字都是寄存器名称。CS代表“代码段”，标记当前指令的邻域。IP代表“指令指针”，标记下一条指令。

### BIOS和UEFI

固件是内置于主板上的一个小启动程序。

BIOS代表基本输入输出系统。这是较旧的风格。BIOS进行了快速的健康检查，称为POST，查看启动顺序，尝试每个设备。如果它发现某个磁盘的第一个512字节扇区以标记字节`0x55`和`0xAA`结尾，它将该设备视为可启动的。BIOS将该扇区复制到内存`0x7C00`并跳转到那里。因为该扇区很小，所以它通常只知道如何加载下一个更大的部分。

UEFI是现代替代品。它仍然启动机器，但直接理解文件系统并能够加载更大的启动程序，而无需进行旧的“第一个扇区”舞蹈。UEFI还向操作系统传递更丰富的信息。不同的路径，相同的目标：将控制权转交给一个能够加载Linux的启动程序。

### 认识引导加载程序

引导加载程序是将操作系统放入适当位置的引导者。GRUB是PC上常见的选择。它读取其配置，如果你安装了菜单，显示一个菜单并将Linux内核加载到内存中。Linux内核文件实际上包含两件事：

-   一个仍在实模式下运行的小型设置程序
-   一个稍后将解压的大型压缩内核

GRUB还填写一个称为设置头的小结构，包含有用的信息：它放置内核的位置、命令行所在位置、如果存在的initrd所在位置。然后它跳转到设置程序。

### 设置程序创建安全空间

在Linux可以进行任何有趣的事情之前，设置代码创建一个可预测的工作空间。

它排列段寄存器，以便内存拷贝每次都呈现相同的行为。你将看到的名称包括CS代表代码、DS代表数据和SS代表栈。它还清除一个名为“方向标志”的CPU位，以便拷贝指令在内存中向前移动。

它创建一个栈。栈是一个后进先出的工作台，函数用于存储临时值。SS指定栈使用的段。SP是指向栈当前顶部的指针。

它清除一个称为BSS的区域。BSS是全局变量必须以零开始的地方。C代码假定BSS为零。设置程序在该整个范围内写入零，以保持这一承诺。

如果你在内核命令行上传递了`earlyprintk`，设置代码还会编程串口，以便能够打印非常早期的消息。这在图形尚未准备好时是有用的。

最后，设置程序询问固件“我们究竟有多少可用的RAM以及有哪些孔”。在旧BIOS上，这个调用通常被人们昵称为e820，它返回一个可用和保留范围的简单列表。内核将使用此列表以避免踩到固件的脚。

完成后，设置代码调用它的第一个C函数，名为`main`。此时我们仍在小型旧实模式下。接下来的工作是离开它。

**小解释：中断** 中断是一种硬件或软件的“打扰”，会暂停CPU正在做的事情并运行一个小处理程序以应对某些紧急情况。定时器滴答声是一个中断。按键是一个中断。这里有两种类型。可屏蔽中断遵循你的规则，并且可以暂时阻塞，以免在微妙的时刻激活。不可屏蔽中断，通常称为NMI，总是会介入，因为它们通常报告严重的硬件问题。在切换模式时，我们将控制这两者，因此在过程中不会有意外情况。

## 第二部分 — 离开实模式，步入32位领域，最终到达64位

现代Linux在PC上运行在长模式中，这是x86_64的64位模式。你不能直接从实模式跳入那里。路径是从实模式到保护模式，然后从保护模式到长模式。本部分涵盖这一路径，并在途中解释相关术语。

### 保护模式，无术语迷雾

保护模式是为了超越1980年代的限制而引入的32位世界。它增加了两个核心概念。

全局描述符表（GDT）是一个简短的段描述列表。一个描述说“此段从这里开始，覆盖这么多，并被允许执行这些操作。”Linux将其保持简单。它使用平面模型，这意味着基数为零，大小覆盖整个32位空间。当一切都是平面的时，地址看起来再次像普通数字。

中断描述符表（IDT）是一个“电话号码”目录，用于紧急调用。如果中断到达，CPU在IDT中查找条目并跳转到列出的处理程序。在切换过程中，我们加载一个微小的占位符IDT，因为我们即将阻止中断。功能齐全的IDT在实际内核接管后会到来。

### 小心的切换

设置代码首先禁用吵闹的部分。它通过一条指令禁用可屏蔽中断。它使旧的PIC芯片安静，以便硬件中断在一瞬间完全阻塞。它打开A20线。这是个历史上的怪癖。早期的PC在1兆字节处将地址环绕。打开A20去除了这种环绕，因此较高的地址按你期望的方式工作。它重置数学协处理器，以便浮点状态干净。

然后，它加载一个微小的GDT，仅包含我们现在所需的内容，以及一个微小的IDT。最后，它在一个称为CR0的控制寄存器中设置一个名为PE的位，并执行一次远跳转。该跳转从GDT重新加载代码段并锁定为保护模式。它重新加载数据和栈段，并调整栈指针以匹配新的平面世界。

我们现在处于32位保护模式。

**小解释：控制寄存器** CPU有几个用于开关的特殊寄存器。CR0打开保护模式。CR3保存页表顶部的地址，我们稍后将需要它。CR4启用一组扩展功能，如较大的页表条目。

### 为什么我们仍没有完成

Linux想要64位。这是长模式。需要两件事。

必须启用分页。分页是在虚拟地址和物理地址之间的翻译器。程序使用虚拟地址。硬件读写物理内存。页表将两者映射到固定大小的块，称为页。在PC上，普通页面为4千字节。也有更大的页面。引导早期，内核使用2兆字节的页面快速描述低内存。

在一个特殊寄存器中，名为EFER的单个位LME必须被设置，以允许长模式。EFER是一个特定于模型的寄存器，换句话说就是“用于某些CPU功能的寄存器”。

### 建立足够的分页

32位序幕构建了一小组页表，表明“对于这个区域，虚拟等于物理。”这称为身份映射。这足以安全地启用分页。

为了使这项工作，代码在CR4中启用PAE以便使用更大的条目。它构建一组最小的表，覆盖低内存，以2兆字节为单位。它将顶级表的地址写入CR3。分页现在准备就绪。

最后，它在EFER中设置LME，并执行一次远返回到写为64位代码的标签。长模式现在激活。段仍然是“平的”，但地址和寄存器为64位宽。

**为什么如此额外小心** 在一个运行中的系统中切换模式就像在行驶中换车胎。代码阻止中断，准备所需的最小表，翻转位，然后才邀请中断回来。慢而稳妥能防止奇怪的半切换状态。

## 第三部分 — 解压真实内核，修正地址，以及Linux有时为何会移动自己

我们有一个启用了分页的64位CPU和内存中的压缩内核。现在小型64位存根执行实际工作：在需要时让位，解压内核，修正地址（如果内核不在其默认位置），并跳转。

### 清理路径和设置安全网

存根首先确定它实际上在什么地方运行。早期代码被链接为如果它处于地址零，然后在运行时计算其真实基址。如果预定的解压内核的目的地与存根重叠，它将自己复制到一个安全的位置。

它清除了自己的BSS，以便全局状态从干净状态开始。

它加载一个最小IDT，其中有两个处理程序。一个用于页错误，一个用于NMI。页错误发生在CPU无法找到它刚刚尝试使用的虚拟地址的映射时。在我们早期的身份映射世界中，微小的页错误处理程序可以即时添加丢失的映射并继续。NMI处理程序确保在仍在启动过程中，不可屏蔽中断不会崩溃机器。

它还为即将接触到的区域构建身份映射。这包括内核未来的家、引导加载程序填写的小引导参数页，以及命令行缓冲区。

### 解压Linux…

一个通常称为`extract_kernel`的C函数接管。它为临时缓冲区留出一个小堆，打印经典行，并使用内核构建时所用的任何算法解压内核。gzip、xz、zstd、lzo和其他都插入到同一个封装中。

当字节被提取后，解压缩程序读取内核的ELF头部。ELF是可执行与可链接格式的缩写，它既是一种文件格式也是一种映射。它说明哪些块是代码，哪些是数据，以及每个块要居住的位置。解压程序将每一块复制到其所属的位置。

如果内核在与其构建位置不同的地址加载，解压程序会应用重定位。重定位是对指针或包含地址的指令所做的小调整。解压程序依次遍历这些重定位，并对每个位置进行补丁，以确保它指向我们实际使用的地址空间中的正确位置。

当一切就位后，解压程序将真实内核的入口点返回并跳转到那里，同时传递引导参数的指针。从此刻起，你进入了完整的内核。你遇到的第一个函数是`start_kernel`，大型初始化开始。

### 为什么内核有时会故意移动自己

你可能看到内核日志中提到kASLR。它代表内核地址空间布局随机化。这个想法很简单。如果攻击者不知道内核在内存中的位置，某些攻击将变得更加困难。

在引导的早期，如果启用了kASLR，解压程序随机选择两个“基址”：

-   一个是物理基址，内存中数据存放的位置
-   一个是虚拟基址，内核运行时所使用的起始虚拟地址

它如何选择而不破坏任何东西？

它构建了一个不允许触碰的列表。这包括解压程序本身、压缩映像、初始ramdisk、引导参数页和命令行缓冲区。它还可以包括使用命令行的`memmap=`选项保留的范围。

它扫描固件的内存映射，以找到大的空闲区域。对每个空闲区域，它计算合适大小的对齐的“插槽”可以容纳多少。然后，它使用最佳的早期熵源生成一个随机数。在现代CPU上，这可能是一个硬件随机指令。它将这个数字缩减至总插槽数并选择匹配的插槽，这就是物理基址。虚拟基址以同样方式选择，但在内核的虚拟地址窗口内。

如果没有合适的存在，代码回退到默认地址并打印一个小警告。如果你在命令行上传递了`nokaslr`，则有意跳过随机化步骤。

___

## 你可以收藏的快速术语表

**十六进制。** 以`0x`开头的16进制数。`0x10`是16。`0x100000`是1兆字节。十六进制与比特清晰映射，因此低级代码使用它。

**寄存器。** CPU内部保存当前数字的微小槽位。示例：CS、DS、SS、IP、SP。

**段与偏移。** 用于构建实模式地址的两部分。物理地址等于段乘以16加上偏移。

**BIOS。** 启动机器、检查硬件并将第一个引导扇区加载到内存中的旧式固件。

**UEFI。** 现代固件，理解文件系统并直接加载较大的引导程序。

**引导加载程序。** 将内核放入内存并向其传递系统信息的引导者。GRUB是一个常见的选择。

**栈。** 函数的后进先出工作台。SS选择其段。SP指向当前顶部。

**BSS。** 全球变量必须从零开始的区域。内核设置代码在C运行之前清除它。

**中断。** 硬件或软件的快速“打扰”。CPU暂停，运行一个小处理程序，然后恢复。可屏蔽中断可以暂时阻止。NMI不能。

**GDT。** 全局描述符表。简短的段描述符列表。Linux将其设置为简单的平面模型。

**IDT。** 中断描述符表。中断处理程序的目录。早期引导使用最小的一个。完整内核稍后安装真实的。

**A20线。** 历史开关，必须打开以便在旧PC上正确寻址1兆字节以上。

**保护模式。** 32位模式，引入GDT和IDT并允许分页。

**长模式。** x86_64的64位模式。需要启用分页以及在EFER寄存器中设置的名为LME的位。

**分页。** 从虚拟地址到物理内存的翻译器。通过页表实现。

**页表。** 将虚拟页面映射到物理页面的数据结构。早期引导使用身份映射。正常页面为4KB。早期引导通常使用2MB页面快速覆盖。

**CR0，CR3，CR4。** 控制寄存器。CR0启用保护模式。CR3指向页表顶部。CR4启用扩展功能，比如PAE。

**EFER。** 一个特殊的寄存器，包含长模式启用以及其他位。

**ELF。** 内核的磁盘格式，带有内置的属于什么地方的映射。

**重定位。** 在代码的加载基址不同于构建基址时进行的修正。

**kASLR。** 在启动时随机化内核基址以使利用更困难。

[GPT-4o mini]
