# [理解汇编第一部分: RISC-V](https://mcyoung.xyz/2021/11/29/assembly-1/)

一个[图灵沼泽](https://en.wikipedia.org/wiki/Turing_tarpit)是一个图灵完备的编程语言，但在其中完成任何事情都是非常痛苦的。一个特别显著的沼泽是[Brainfuck](https://en.wikipedia.org/wiki/Brainfuck)，它在初学者和中级程序员中有着不可接近的声誉，并且只对最高级的程序员可用，因此得名，正如维基百科所说：

> 该语言的名字参考了俚语术语_脑残_，指的是那些复杂或异常到超过一个人理解极限的事物。

汇编语言是任何计算机上“最低级”的编程语言，也有类似的声誉：困难、神秘，难以理解。无论如何，没有程序员会想与之打交道的图灵沼泽。

尽管高级程序员通常不再将汇编视为神秘和不可接近，但我认为这仍然是一个有价值的主题，甚至对中级程序员来说也是如此，并且可以变得易于接触和有趣。

本系列旨在如此：假设你已经在使用像Rust、C++或Go这样的编译语言，那么汇编对于你来说_有什么相关性_？

> 如果你只是想学习汇编，根本不想了解动机，你可以直接[跳过](https://mcyoung.xyz/2021/11/29/assembly-1/#diving-in)。
> 
> 本系列旨在学习_理解_汇编，而非编写它。我偶尔会为生活写汇编，但我并不是一个_专家_，我并不特别喜欢它。不过，我确实阅读了大量的汇编。

## [这到底是什么？](https://mcyoung.xyz/2021/11/29/assembly-1/#what-is-it-anyways)

正如每个程序员所知，计算机是非常愚蠢的。它们非常擅长遵循指令，而其他事情则一窍不通。实际上，计算机是_如此_愚蠢，以至于它只能串行处理基本指令[^1]，一个接一个。指令非常简单：“将这两个值相加”，“将这个值从这里复制到那里”，“去执行这些指令”。

计算机处理器通过电子电路实现这些指令。在其最基本的层面上，每台计算机看起来都像以下程序：

```c
size_t program_counter = ...;
Instruction *program = ...;

while (true) {
  Instruction next = program[program_counter];
  switch (next.opcode) {
    // 确定你应该做什么并执行它。
  }
  program_counter++;
}
```

数组`program`是你的程序，它以某种二进制格式编码为一系列“机器指令”。例如，在RISC-V程序中，每条指令是一个32位整数。这个二进制格式称为_机器码_。

例如，当RISC-V处理器遇到值`5407443`时，解码电路决定这意味着它应当取“寄存器”`a0`中的值，加上`10`，并将结果放入寄存器`a1`中。

> ### [解码指令](https://mcyoung.xyz/2021/11/29/assembly-1/#decoding-instructions)
> 
> `5407443`似乎是模糊的，但当以二进制形式查看时，我们可以看到处理器是如何解码它的：
> ```plaintext
> > 0b 000000000101 00101 000 00110 0010011
> >    \__________/ \___/ \_/ \___/ \_____/
> >     |           |     |   |     |
> >     imm         rs1   fn  rd    opcode
> ```
> `opcode`描述了这是什么类型的指令以及它的格式；`0b0010011`表示这是一个“立即数算术”指令，使用的是上面提到的“I型”格式。`fn`进一步指定该操作的功能；`0b000`，结合`opcode`的值，意味着这是一条_加法_指令。
> 
> `rs1`是源寄存器：它通过其索引指定源寄存器的名称`a0`，即`0b00101`。类似地，`rd`通过其索引`11`指定目标`a1`。最后，`imm`是要加的值`0b000000000101`，即`10`。常数值直接在指令中出现，因此称为_立即数_。

但是，如果你是一个人类在给计算机编程，手动编写所有这些…是非常60年代的，你可能更愿意拥有文本表示，这样你可以更简单地将其写作`addi a1, a0, 10`。

`addi a1, a0, 10`是一行汇编：它以文本形式描述了一条_单一_指令。汇编语言“只是”程序机器码的文本表示。你的汇编器可以将文本转换为机器指令，而_反汇编器_则反转这个过程。

这些指令的简单性使得汇编成为一种图灵沼泽：你仅能获得最基本的操作：你负责构建_其他一切_。

### [关于架构](https://mcyoung.xyz/2021/11/29/assembly-1/#on-architectures)

并没有“一个”汇编语言。每台计算机都有不同的指令集架构，或称“ISA”；我将“指令集”、“架构”和“ISA”互换使用。每个ISA都有一个相应的汇编语言，描述该ISA的特定指令，但它们通常具有类似的整体结构。

为了简便，我将专注于三种ISA，按照以下顺序介绍：

1. RISC-V，一种现代而相对简单的指令集（具体而言是rv32gc变体）。这就是第一部分。
2. x86\_64，这是你正在阅读的设备的指令集（除非它是手机、Apple M1笔记本电脑或类似任天堂Switch之类的设备）。这就是第二部分。
3. MOS 6502，一种相对古老的ISA，但在非常小的微控制器中仍然流行。这就是第三部分。

我们从RISC-V开始，因为它是一种特别优雅的ISA（最初是为学术研究而开发的），同时仍代表大多数ISA提供的操作。

未来，我可能会深入研究一些其他更专业的ISA。

## [但是_为什么_？](https://mcyoung.xyz/2021/11/29/assembly-1/#but-why)

实际上，编写真实的汇编语言是非常罕见的。多亏了现代（相对来说）语言如Rust、C++和Go，甚至像Haskell和JavaScript这样的语言，几乎没有程序员再需要编写汇编。

但这只是因为它是由_计算机本身_编写的主要语言。编译器的工作，基本上，是为你编写你本来需要写的汇编。为了更好地理解编译器为你做了什么，你需要能够阅读其输出。

在这时，可能值得看看我关于链接器的[文章](https://mcyoung.xyz/2021/06/01/linker-script/#seriously-whats-a-linker)，作为C编译模型的复习。

例如，假设我们有下面这个非常简单的C程序。

```square.c
#include <stdio.h>

int square_and_print(int x) {
    x *= x;
    printf("%d\n", x);
    return x;
}
```

Clang，我选择的C编译器，可以直接通过`clang -c square.c`将其转化为一个库。`-c`要求编译器在链接步骤之前停止，输出_object file_ `square.o`。我们可以通过写`clang -S square.c`来要求编译器停止更早，这将输出编译器产生的`square.s`汇编文件！在这个例子中，以及本帖中的几乎所有其他例子中，我使用的目标是RISC-V：`-target riscv32-unknown-elf -march=rv32gc`。

如果你用`-Oz`构建，以使代码尽可能小（这也使得观察发生了什么变得最简单），你将得到如下内容：

```square.s
.text
	.file   "square.c"
	.globl  square_and_print
square_and_print:
	addi    sp, sp, -16
	sw      ra, 12(sp)
	sw      s0, 8(sp)
	mul     s0, a0, a0          // !
	lui     a0, %hi(.L.str)
	addi    a0, a0, %lo(.L.str)
	mv      a1, s0
	call    printf              // !
	mv      a0, s0
	lw      s0, 8(sp)
	lw      ra, 12(sp)
	addi    sp, sp, 16
	ret

	.section        .rodata
.L.str:
	.asciz  "%d\n"
```

这里发生了很多事情！但注意带有`// !`的两行：第一行是`mul s0, a0, a0`，这是乘法`x *= x;`。第二行是`call printf`，这是我们调用`printf()`的函数调用！我会很快解释其他所有内容的含义。

编写汇编并不是一项关键技能，但能够阅读它是非常有用的。实际上，非常有用，以至于存在一个网站，用于快速生成大量编译器的汇编输出：即[Compiler Explorer](https://godbolt.org/)，通常被称为“godbolt”，以其创始人Matt Godbolt的名字命名。能够比较不同编译器的输出可以帮助理解它们的工作方式！点击代码框中的`godbolt`按钮以获取它的godbolt。

“低级”语言如C并不是唯一可以检查汇编输出的语言。Godbolt支持Go语言：例如，点击下面的`godbolt`按钮。

```go
package sq

import "fmt"

func SquareAndPrint(x int) int {
    x *= x
    fmt.Printf("%d\n", x)
    return x
}
```

希望这足以激励你直接进入这门语言。打开一个godbolt标签来玩转示例是非常有用的！

## [深入探讨](https://mcyoung.xyz/2021/11/29/assembly-1/#diving-in)

那么，让我们假设你_确实_想阅读汇编。我们怎么做呢？

让我们再看看上面的`square.c`示例。这次，我添加了注释，解释代码的所有重要部分，包括_汇编器指令_，所有指令以`.blah`的形式呈现。请注意，_实际_编译器输出包含更多指令，这些指令会妨碍阐述。

下面有很多的术语，我还没有定义。我会逐步解释这段代码的作用，因此请随时根据需要参考它，使用[这个便捷的链接](https://mcyoung.xyz/2021/11/29/assembly-1/#big-example)。

```square.s
	// 这告诉汇编器将以下所有代码放置在`.text`段中，
	// 该段用于可执行数据。
	.text

	// 这只是工具可以用来判断可执行文件构建方式的元数据。
	.file   "square.c"

	// 这要求汇编器将`square_and_print`标记为一个
	// 可外部链接的符号。其他引用`square_and_print`的
	// 文件将在链接时能找到它。
	.globl  square_and_print

square_and_print: // 这是一个标签，它为可执行文件中的这个位置
		  // 提供了一个名称，可以供引用。它们与C中的`goto`
		  // 标签非常相似。
		  //
		  // 我们稍后将看到更多标签。


	// 这是函数前奏，它“设置”函数：为栈分配空间并保存
	// 返回地址，以及其他调用约定上的繁琐。
	addi    sp, sp, -16
	sw      ra, 12(sp)
	sw      s0, 8(sp)

	// 这是我们之前的`x *= x;`！请注意，编译器在某时将其重写为
	// `temp = x * x;`，因为目标寄存器是`s0`。
	mul     s0, a0, a0

	// 这两条指令加载字符串常量的地址；这种模式对于RISC-V是特定的。
	lui     a0, %hi(.L.str)
	addi    a0, a0, %lo(.L.str)
	
	// 这将乘法结果复制到`a1`。
	mv      a1, s0

	// 调用`printf`！
	call    printf

	// 将`s0`移动到`a0`，因为它是返回值。
	mv      a0, s0

	// 这是函数尾声，它恢复状态，恢复在前奏中保存的
	// 状态并从栈框架中取消分配。
	lw      s0, 8(sp)
	lw      ra, 12(sp)
	addi    sp, sp, 16
	
	// 我们完成了；从函数返回！
	ret

	// 这告诉汇编器将以下内容放置在`.rodata`段中，
	// 用于只读常量如字符串。
	.section        .rodata

.L.str: // 给我们的字符串常量一个私有名称。根据惯例，
	// .L标签是编译器发出的“私有”名称。

	// 将一个ASCII字符串发出到`.rodata`中，并在末尾加上额外的空字符：
	// 这就是`z`所代表的含义。
	.asciz  "%d\n"
```

### [核心语法](https://mcyoung.xyz/2021/11/29/assembly-1/#the-core-syntax)

所有汇编器都是不同的，但核心语法往往是相同的。有三种主要的语法形式：

- 指令，由一个_助记符_后跟一定数量的_操作数_组成，例如上述的`addi sp, sp -16`和`call printf`。这些是机器码的文本编码。
- 标签，由符号后跟一个冒号组成，比如`square_and_print:`或`.L.str:`。这些用于让指令操作数引用程序中的位置。
- 指令，因汇编器而异。GCC风格的汇编如上使用了`.directive arg, arg`的语法，如`.text`、`.globl`和`.asciz`。它们以各种方式控制汇编器的行为。

汇编器的目的在于读取`.s`文件，并将其序列化为二进制的`.o`文件。这有点像编译器，但它几乎不执行任何有趣的工作，除了知道如何编码指令。

指令控制这种序列化的发生（如移动输出指针）；指令原封不动地输出，标签引用对象文件中的位置。简单吧？

### [指令的构造](https://mcyoung.xyz/2021/11/29/assembly-1/#anatomy-of-an-instruction)

让我们看看`square_and_print`中的第一条指令：

```
// RISC-V 汇编
	addi sp, sp, -16
	---- --  --  ---
	 |   |   |    |
	助记符   |   立即数操作数
	     |  输入操作数
	     |
	    输出操作数
```

第一个标记称为_助记符_，它是指令所做的事情的简略缩写。在这种情况下，`addi`的意思是“带立即数的相加”。

`sp`是一个_寄存器_。寄存器是直接连接到处理器的特殊变量，既可以在指令中用作操作数。只有寄存器被允许作为操作数的程度根据架构而异；RISC-V仅允许使用寄存器，但x86，如我们将看到的，则不是。寄存器有多种类型，但`sp`是一个GPR，或“通用寄存器”；它持有一个机器字大小的整数，在32位的RISC-V中…是32位[^2]。

> #### [RISC-V 寄存器](https://mcyoung.xyz/2021/11/29/assembly-1/#risc-v-registers)
> 
> RISC-V最让我喜欢的部分之一是它如何命名其寄存器。它有32个GPR，命名为`x0`到`x31`。然而，这些寄存器有所谓的“ABI名称”，指定每个寄存器在ABI中的_角色_。
> 
> 这些名称的有用性将在我们讨论[调用约定](https://mcyoung.xyz/2021/11/29/assembly-1/#the-calling-convention)时变得更加明显，所以请随意稍后再回来看。
> 
> `x0`被称为`zero`，因为它的特殊属性：对它的写入被忽略，读取总是返回零。这在对某些常见操作的编码中非常便利：例如，可以用于快速将一个常数值放入寄存器：`addi rd, zero, 42`。
> 
> `x1`、`x2`、`x3`和`x4`有特殊角色，通常不用于一般计算。前两个是链接寄存器`ra`，它保存返回地址，以及`sp`，栈指针。
> 
> 后两个是`gp`和`tp`；全局ppointer和线程ppointer；它们的角色有点复杂，所以我们在这篇文章中不讨论它们。
> 
> 其余寄存器属于三种类型之一：_参数_寄存器、_保存_寄存器和_临时_寄存器，这些名称是根据它们在调用一个函数时的角色命名的（如下所述）。
> 
> 参数寄存器是`x10`到`x17`，使用名称`a0`到`a7`。保存寄存器是`x8`、`x9`和`x18`至`x27`，称为`s0`至`s11`。临时寄存器是`x5`到`x7`和`x28`至`x31`，称为`t0`至`t6`。
> 
> 出于个人偏好，你可能会发现我在大多数例子中使用参数寄存器。

`-16`是一个_立即数_，它是直接编码在指令中的字面值。`addi sp, sp, -16`的编码将包括`-16`的二进制表示（在RISC-V的情况下，为12位整数）。\[上面的解码示例\]{#decoding-instructions}显示立即数如何在指令中直接编码。

立即数允许小但固定的整数参数与指令紧紧关联，这对代码大小和性能都是有利的。

在RISC-V中，第一个操作数（几乎）总是输出。`addi, rd, rs, imm`应读作`rd = rs + imm`。几乎所有汇编语法遵循这一约定，这被称为[三地址代码](https://en.wikipedia.org/wiki/Three-address_code)。

还存在其他类型的操作数：例如，`call printf`引用了符号`printf`。汇编器实际上并不知道`printf`的位置，它将在对象文件中发出一条小注释，告诉链接器找到`printf`并根据注释中的某些指令采用其汇编。这个注释称为_重定位_。

指令`lui a0, %hi(.L.str)`和`addi a0, a0, %lo(.L.str)`使用了特定于RISC-V的`%lo`和`%hi`操作数类型；它们将符号地址的低12位和高20位分别加载到立即数操作数中。这是RISC-V特有的将地址加载到寄存器的一种模式，大多数汇编器使用_伪指令_ `la a0, .L.str`（其中`la`代表“加载地址”）提供此指令。

大多数架构都有自己的特定的架构特定的操作数类型来处理架构的特殊性。

### [指令类型](https://mcyoung.xyz/2021/11/29/assembly-1/#types-of-instructions)

可用的指令通常是通过提供三类功能之一来激励的：

1. 图灵完备的[寄存器机器](https://en.wikipedia.org/wiki/Register_machine)执行环境。这使得汇编具有图灵沼泽的性质：仅提供绝对最低限度的控制流和内存访问。
2. 通过常见操作实现位串和整数的有效硅实现，从算术到加密算法。
3. 构建安全的操作系统，托管虚拟机，以及驱动处理器外部硬件，如显示器、键盘或扬声器。

指令可以大致分为四类：算术、内存、控制流和“其他一切”。在过去三十年里，通用架构的基准通常是“足以实现C运行时。”

#### [算术指令](https://mcyoung.xyz/2021/11/29/assembly-1/#arithmetic-instructions)

算术操作占据了指令集的大部分。这总是包括加法、减法和按位与、按位或和异或，以及一元的非和负操作。

在RISC-V中，这些有两个变体：三寄存器版本和两寄存器一个立即数版本。例如，`add a0, a1, a2`是加法的三寄存器版本，而`addi a0, a1, 42`是立即数版本。然而，没有`subi`指令，因为你可以使用负的立即数与`addi`结合使用。

`not`和`neg`在RISC-V中并不是实际指令，而是伪指令：`not a0, a1`编码为`xori a0, a1, -1`，而`neg a0, a1`变为`sub a0, zero, a1`。

大多数指令集还提供位移操作，通常有三种风格：左移、右移和_算术_右移；算术右移的定义使得它在有符号整型上表现为对2的幂除法。RISC-V对这些指令的命名为`sll`、`srl`和`sra`。

乘法和除法相对较少，因为在硅中实现它们是昂贵的；较小的设备没有此支持[^3]。特别是，除法在硅中的实现非常复杂。指令集通常在除以零时具有不同的行为：一些体系结构会导致故障，类似于内存错误，而一些，如RISC-V，则生成一个良定义的陷阱值。

通常还有一条“复制”指令，将一个寄存器的值移动到另一个寄存器，这有点像简单的算术指令。RISC-V称之为`mv a0, a1`，但它只是一条伪指令，展开为`addi a0, a1, 0`。

某些体系结构还提供更奇特的算术。以下是一些有时可用的示例：

- 位旋转，类似于位移，但从整数边缘移出的位会回到整数的另一端。这对于包括ARX密码（如[ChaCha20](https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant)）在内的大量数字算法非常有用。
- 字节反转，可用于改变整数的字节序；位反转是类似的。
- 位提取，可用于从另一个字符的位域形成新整数。
- 无进位乘法，像长乘法，但在加法中不再关心进位。这被用于实现[加洛瓦/计数器模式加密](https://en.wikipedia.org/wiki/Galois/Counter_Mode)。
- 融合指令，如`xnor`和`nand`。
- 浮点指令，通常实现[IEEE 754](https://en.wikipedia.org/wiki/IEEE_754)标准。

还有一种特殊类型的算术指令称为_向量指令_，但我将留待下次再讨论。

#### [内存指令](https://mcyoung.xyz/2021/11/29/assembly-1/#memory-instructions)

加载指令将内存从RAM取入寄存器，而存储指令将其写回。这些指令是实现指针的关键。

它们有各种不同的大小：RISC-V有`lw`、`lh`和`lb`用于从位置加载32位、16位和8位值；`sw`、`sh`和`sb`是它们的存储对应物。64位的RISC-V也提供`ld`和`sd`用于64位的加载和存储。

加载/存储指令经常接受偏移来索引内存。`lw a1, 4(a0)`[^4]实际上是`a1 = a0[4]`，将`a0`视作指针。

这些指令通常具有_对齐_约束：指针值必须（或至少应该）被加载的字节数整除。例如，RISC-V要求`lw`仅在可以被4整除的指针上使用。该约束简化了微架构；即使在不强制限制的架构中，对齐的加载和存储通常要快得多。

该类别还包括实现原子的指令，例如x86的`lock cmpxchg`和RISC-V的`lr`/`sc`。原子 fundamentally 改变了从RAM读取和写入的语义，因此需要特殊的处理器支持。

某些架构，如x86、65816和最近的ARM，提供实现`memcpy`及其同类的硬件指令，例如在x86中，这被称为`rep movsb`。

#### [控制流指令](https://mcyoung.xyz/2021/11/29/assembly-1/#control-flow-instructions)

控制流是将我们光荣的计算器转变为图灵沼泽的秘密成分：它们允许基于当前状态改变程序执行的流。

_无条件跳转_实现`goto`：给定某个`label`，指令`j label`直接跳转到它。`j`可以被视为写入一个特殊的`pc`寄存器，该寄存器保存程序计数器。RISC-V还提供了一个_动态_跳转，`jr`，它将跳转到寄存器中的地址。函数调用和返回是一种特殊的无条件跳转。

_条件跳转_，通常称为_分支_，实现`if`。`beq a0, a1, label`将在`a0`和`a1`包含相同值时跳转到`label`。RISC-V提供针对所有类型比较的分支指令，如`bne`、`blt`和`bge`。

条件和无条件跳转可以结合使用以构建循环，就像我们在C语言中可以使用`if`和`goto`一样。

例如，假设要将一块内存清零：

```
// RISC-V 汇编
	// 假设a0是区域的起始位置，a1是字节数。

	// 将a1设置为区域的结束位置。
	addi a1, a0, a1
loop_start:
	// 如果a0 == a1，我们完成了！
	beq a0, a1, loop_done

	// 将零字节存储到`a0`，并前进指针。
	sb zero, 0(a0)
	addi a0, a0, 1

	// 再来一次！
	j loop_start
loop_done:
```

#### [杂项指令](https://mcyoung.xyz/2021/11/29/assembly-1/#miscellaneous-instructions)

“其他一切”就是，一切……

无操作指令什么也不做：`nop`的唯一目的是在指令流中占用空间。无操作指令可以用来填充指令流中的空间，提供用于稍后链接的空间，或者实现[`nop`冰雕](https://en.wikipedia.org/wiki/NOP_slide)。

用于更改处理器状态的指令，如RISC-V中的`csrrw`和`x86`中的`wrmsr`也属于此类别，以及像内存预取气味指令。

这里也有特殊控制流指令：`ecall`是RISC-V的“系统调用”指令，它向内核“陷阱”，让它执行某项操作；其他架构也有类似的指令。

断点指令和[“栅栏”指令](https://www.felixcloutier.com/x86/lfence)也属于这里。

## [调用约定](https://mcyoung.xyz/2021/11/29/assembly-1/#the-calling-convention)

函数是所有编程的核心抽象。汇编也不例外：那里也有函数！

就像在任何语言中一样，函数被_传递_一组参数，执行一些工作，并_返回_一个值。例如，在C语言中：

```c
int identity(int x) {
  return x;
}

// ...

identity(5)  // 返回5。
```

不幸的是，汇编语言中并没有像函数调用那样的语法。与其他一切一样，我们需要逐条指令执行这一过程。我们通常只得到一条`call`指令，它将在某处设置返回地址，然后执行`ret`指令，使用该返回地址跳转到函数被调用的地方。

我们需要一种方式来传递参数、返回计算值，并维护调用栈，以便每个函数的返回地址被完整地保留，以供其`ret`指令使用。我们还需要使其具有普遍性：如果我引用了一个库，我应该能够调用它的函数。

这个机制称为平台ABI的_调用约定_。它是一个约定，因为所有库必须在其公开API中遵守它，以便代码在运行时能够正确工作。

### [慢动作的函数调用](https://mcyoung.xyz/2021/11/29/assembly-1/#a-function-call-in-slow-mo)

在指令级别，函数调用看起来像这样：

1. 调用前准备。调用者通过将参数放置在预定位置为函数调用的参数做好准备。这些通常是寄存器或栈上的位置。a. 调用者还将_调用者保存的寄存器_保存在栈上。
2. 跳转到函数。调用者执行一条`call`指令（或其他函数调用指令；几乎所有架构都有一条）。这将程序计数器设置为被调函数的第一条指令。
3. 函数前奏。被调用者在执行代码之前进行一些设置。a. 被调用者以架构特定的方式为栈分配空间。b. 被调用者将_被调用者保存的寄存器_保存在该栈空间中。
4. 函数体。函数的实际代码现在开始运行！该函数的此部分需要确保返回值出现在函数的_返回槽_中。
5. 函数尾声。被调用者撤销在前奏中做的所有操作，如恢复已保存的寄存器，并执行一条`ret`（或等效）指令以返回。
6. 调用后清理。调用者再次执行；它可以在函数调用后立即恢复所需的任何已保存状态，并可以从返回槽中检索返回值。  
在某些ABI中，如C++在Linux上的ABI，这时会运行参数的析构函数。（Rust和Windows上的C++ 使用_被调用者销毁的参数_）。
    

当人们说函数调用存在开销时，他们所指的就是这个。`call`指令不仅导致处理器停止其管线，还造成所有类型的工作被丢弃，状态需要在函数边界仔细保存和恢复，以维护调用栈的假象。

不需要使用太多寄存器的小函数可以避免一些设置和清理，而不调用任何其他函数的_叶函数_几乎可以避免所有操作！

几乎所有RISC-V的寄存器都是调用者保存，除了`ra`和“保存”寄存器`s0`和`s11`。

被调用者保存寄存器很方便，因为它们不会被函数调用抹除。我们实际上可以看到`printf`的调用使用此特性：尽管编译器本可以发出`mul a1, a0, a0`并避免`mv`，但这实际上不够优化。我们需要保留该值以返回，`a1`是调用者保存的寄存器，因此不管`printf`是否覆盖了`a1`，我们都必须在调用`printf`之前溢出`a1`。然后，必须在`ret`之前重载到`a0`。这会消耗一次RAM的使用。然而，通过发出`mul s0, a0, a0; mv a1, s0`，我们在推测中避免了溢出：如果`printf`被编译为不会修改`s0`，该值永远不会离开寄存器！

### [调用者侧](https://mcyoung.xyz/2021/11/29/assembly-1/#caller-side)

我们可以在对`printf`的调用中看到步骤1和2：

```
// RISC-V 汇编
	lui     a0, %hi(.L.str)
	addi    a0, a0, %lo(.L.str)
	mv      a1, s0
	call    printf
```

在常规[^5] RISC-V调用约定中，按字节大小的参数存储在`a0`到`a7`的寄存器中，如果寄存器空间不够，则会退化为在栈上传递。如果参数过大而不能适合集成寄存器，也会按引用传递。适合两个寄存器的参数可以在寄存器之间分割。

我们可以在上面的[大示例](https://mcyoung.xyz/2021/11/29/assembly-1/#big-example)中看到这一点。第一个参数是一个字符串，按指针传递到`a0`中；`lui`和`addi`执行将该指针放入`a0`的工作。第二个参数`x`在`a1`中传递，复制自在之前的乘法指令`mul`时落到`s0`上的值。

复杂的函数签名需要更多的[^6]工作来设置。

一旦我们将参数准备好，就执行`call`，将执行切换到`printf`的第一条指令。此外，它还将返回地址存储，具体而言，将立即在某个体系结构特定位置存储`call`指令后面的指令的地址。在RISC-V中，这是特殊寄存器`ra`。

### [被调用者侧](https://mcyoung.xyz/2021/11/29/assembly-1/#callee-side)

与此同时，步骤3和4发生在`square_and_print`的前奏/尾声中：

```
// RISC-V 汇编
square_and_print: 
	addi    sp, sp, -16
	sw      ra, 12(sp)
	sw      s0, 8(sp)

	// ...

	lw      s0, 8(sp)
	lw      ra, 12(sp)
	addi    sp, sp, 16
	ret
```

`addi sp, sp, -16`，这就是我们上面所着重观察的，增加了栈的16个字节。`sp`持有_栈指针_，它始终指向栈的顶端。栈向下增长（在大多数架构中！），并且在函数调用之间必须对齐到16字节边界：尽管`square_and_print`只使用了其中的八个字节，但仍然必须分配完整的16个字节。

随后出现的两个`sw`指令将_被调用者保存的寄存器_`ra`和`s0`存储到栈中。请注意，`s1`到`s11`并没有被溢出，因为`square_and_print`没有使用它们！

此时，该函数会执行其工作，无论那意味着什么。这包括将返回值放入返回槽中，对于返回`int`的函数，该槽在`a0`中。一般来说，返回槽与参数类似地传递给调用者：如果它适合寄存器，则使用`a0`和`a1`；否则，调用者为其分配空间并传递一个指向返回槽的指针作为隐藏参数（例如，在`a0`中）[^7]。

尾声的操作逆转了前奏所做的所有操作，恢复已保存的寄存器并缩小栈，然后执行`ret`。在RISC-V中，所有`ret`指令只是跳转到`ra`寄存器所引用的位置。

当然，所有这些工作仅仅是为了保持调用栈的假象；如果`square_and_print`是一个叶函数，它根本不需要溢出任何东西！这将导致几乎微不足道的函数：

```c
int square(int x) {
  return x * x;
}
```

```
// RISC-V 汇编
// `x`已经在a0中，
// 返回值需要位于a0中。简单！
square:
	mul a0, a0, a0
	ret
```

由于叶函数不会调用其他函数，因此它们不需要保存被调用者保存的`tX`寄存器，因此可以自由使用它们而不是`sX`寄存器。

## [目前为止的结束](https://mcyoung.xyz/2021/11/29/assembly-1/#the-end-for-now)

哇！我们已经写了大约六千个单词，来回顾一下我们学到的内容：

1. 计算机非常愚蠢，但至少能够遵循_极其_基本的指令，这些指令被编码为二进制。
2. 汇编语言是这些基本指令的可读人类版本，适用于特定计算机。
3. 汇编语言程序由_指令_、_标签_和_指令_组成。
4. 每条指令由_助记符_后跟零或多个_操作数_。
5. _寄存器_保存机器当前处理的值。
6. 指令可以大致分类为_算术_、_内存_、_控制流_和“杂项”（另有_向量_和_浮动_指令，另作他日讨论）。
7. _调用约定_描述了通用函数的低级接口，包括某些调用前的准备、每个函数的前奏和尾声。

到此为止。RISC-V是一个强大但相对简单的ISA。在下次中，我们将深入探讨更古老、更复杂的Intel x86。

[^1]: 这是一个离谱的谎言，超出了本帖的范围。可以参见，例如，[https://en.wikipedia.org/wiki/Superscalar_processor](https://en.wikipedia.org/wiki/Superscalar_processor)。
[^2]: 什么是机器字，究竟？这实际上取决于上下文。大多数流行架构有一个直接的定义：GPR的大小_或_指针的大小，它们是相同的。  
这对于所有架构并不成立，所以请小心。
[^3]: 感谢这些可以使用前述无处不在的指令进行polyfill。黑客的快乐包含所有相关的算法，所以我不会在这里重复它们。除法polyfills特别有趣。
[^4]: 这有点有趣的是我们没有写`lw a1, a0[4]`以模仿数组语法。在汇编语言的这一特定角落，语法在各个汇编器之间的差异非常显著：在ARM中，我们写`ldr r0, [r1, #offset]`；在x86中，`mov rax, [rdx + offset]`，或者对于AT&T风格的汇编，则为`movq offset(%rdx), %rax`（这与RISC-V的语法惊人地相似！）；在6502中，`lda ($1234, X)`。
[^5]: 调用约定在大多数情况下并不是由体系结构确定的；这就是为何称之为_约定_。x86的约定在Windows和Linux上通常不同，并且通常也与语言有关；C的调用约定通常有文档记录，但C++、Rust以及Go各自发明了自己的约定以处理特定语言的繁琐。  
当然，如果你在编写汇编，你可以做你想要做的（虽然硅片可能为特定推荐的调用约定进行了优化）。  
RISC-V定义了针对基于ELF的目标的推荐调用约定：[https://github.com/riscv-non-isa/riscv-elf-psabi-doc](https://github.com/riscv-non-isa/riscv-elf-psabi-doc)。
[^6]: 以下清单展示了各种不同参数的传递方式。输出并不完全是Clang所发出的，因为为了清晰，我清理了一些内容。  
```c
#include <stdio.h>
#include <stdint.h>
#include <stdnoreturn.h>

struct Pair {
  uint32_t x, y;
};
struct Triple {
  uint32_t x, y, z;
};
struct Packed {
  uint8_t x, y, z;
};

// `noreturn`使得`call_it`中的伪前奏和伪尾声消失。
noreturn void all_the_args(
  uint32_t a0,
  uint64_t a1a2,
  struct Pair a3a4,
  struct Triple a5_by_ref,
  uint16_t a6,
  struct Packed a7,
  uint32_t on_the_stack,
  struct Triple stack_by_ref
);

void call_it(void) {
  struct Pair u = {7, 9};
  struct Triple v = {11, 13, 15};
  struct Packed w = {14, 16, 18};
  all_the_args(
    42, -42,  u, v,
     5,   w, 21, v
  );
}
```  
```cpp
// RISC-V 汇编
call_it:
  // 为栈保留空间。
  addi    sp, sp, -48

  // 将`&call_it.v`装入`a3`。
  lui     a3, %hi(call_it.v)
  addi    a3, a3, %lo(call_it.v)

  // 将`*a3`的内容复制到`a0...a2`。
  lw      a0, 0(a3)
  lw      a1, 4(a3)
  lw      a2, 8(a3)

  // 在栈上创建两个`v`的副本作为引用传递。

  // 这就是`a5_by_ref`。
  sw      a2, 40(sp)
  sw      a1, 36(sp)
  sw      a0, 32(sp)

  // 这就是`stack_by_ref`。
  sw      a2, 24(sp)
  sw      a2, 20(sp)
  sw      a0, 16(sp)
  
  // 加载参数寄存器。
  addi    a0, zero, 42
  addi    a1, zero, -42
  addi    a2, zero, -1
  addi    a3, zero, 7
  addi    a4, zero, 9
  // 指向`a5_by_ref`的指针！
  addi    a5, sp, 32
  addi    a6, zero, 5
  // 注意，`a7`是三个打包字节！
  lui     a0, 289
  addi    a7, a0, 14

  // 在栈顶存储`21`（我们的`a8`）
  addi    t0, zero, 21
  sw      t0, 0(sp)

  // 在栈顶第二个位置存储指向`stack_by_ref`的指针
  addi    t0, sp, 16
  sw      t0, 4(sp)

  // 调用它！
  call    all_the_args

call_it.v:
  // 常量`{11, 13, 15}`。
  .word   11
  .word   13
  .word   15
```
[^7]: LLVM偶尔会在某些ABI的某个角落做出有些愚蠢的事情。考虑  
```c
typedef struct { char p[100]; } X;

X make_big(int x) {
  return (X) {x};
} 
```  
我们得到Clang的以下内容：  
```cpp
// RISC-V 汇编
// 注意：返回槽通过`a0`传递，`x`传递通过`a1`。
make_big:
	addi    sp, sp, -16
	sw      ra, 12(sp)
	sw      s0, 8(sp)
	sw      s1, 4(sp)
	mv      s0, a1
	mv      s1, a0
	addi    a0, a0, 1
	addi    a2, zero, 99
	mv      a1, zero
	call    memset
	sb      s0, 0(s1)
	lw      s1, 4(sp)
	lw      s0, 8(sp)
	lw      ra, 12(sp)
	addi    sp, sp, 16
	ret
```  
注意，`sb s0, 0(s1)`将输入值`x`存储到大数组的第一个元素__之前__调用`memset`。如果我们将存储移动到之前，我们可以避免许多愚蠢的事情，包括一些不必要的溢出：  
```cpp
// RISC-V 汇编
make_big:
	addi    sp, sp, -16
	sw      ra, 12(sp)
	sb      a1, 0(a0)
	addi    a0, a0, 1
	mv      a1, zero
	addi    a2, zero, 99
	call    memset
	lw      s1, 4(sp)
	lw      s0, 8(sp)
	lw      ra, 12(sp)
	addi    sp, sp, 16
	ret
```

[GPT-4o mini]
